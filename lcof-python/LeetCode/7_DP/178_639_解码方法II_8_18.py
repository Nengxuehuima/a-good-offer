"""
一条包含字母 A-Z 的消息通过以下的方式进行了 编码 ：

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
要 解码 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，"11106" 可以映射为：

"AAJF" 对应分组 (1 1 10 6)
"KJF" 对应分组 (11 10 6)
注意，像 (1 11 06) 这样的分组是无效的，因为 "06" 不可以映射为 'F' ，因为 "6" 与 "06" 不同。

除了 上面描述的数字字母映射方案，编码消息中可能包含 '*' 字符，可以表示从 '1' 到 '9' 的任一数字（不包括 '0'）。例如，编码字符串 "1*" 可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19" 中的任意一条消息。对 "1*" 进行解码，相当于解码该字符串可以表示的任何编码消息。

给你一个字符串 s ，由数字和 '*' 字符组成，返回 解码 该字符串的方法 数目 。

由于答案数目可能非常大，返回 e9 + 7 的 模 。
"""
class Solution:
    def numDecodings(self, s: str) -> int:
        if not s or s[0] == '0':
            return 0
        n = len(s)
        mod = int(1e9) + 7
        dp = [0 for _ in range(n)]
        if s[0] == '*':
            dp[0] = 9
        else:
            dp[0] = 1
        # 每到一个字母都有两个可解码状态 [第一个除外 所以dp[0] = 1]
        for i in range(1, n):
            # 自己单独就可以解码的状态 n种状态 + 1个字符
            if s[i] != '0': 
                if s[i] != '*':
                    dp[i] += dp[i-1]
                else:
                    dp[i] += dp[i-1] * 9
            # 和前面的一个组成解码状态 n-1状态 + 2个字符(组成一个码)
            # 均不为 *
            # 都是 ** 第一个*不能是0 只能是1和2
            if s[i-1] == '*':
                if s[i] == '*': # [11, 19], [21, 26]  
                    dp[i] += dp[i-2] * 15 if i-2 >= 0 else 15
                elif  '0' <= s[i] <= '6':
                    # 10 11 12 13 14 15 16
                    # 20 21 22 23 24 25 26
                    dp[i] += dp[i-2] * 2 if i-2 >= 0 else 2
                elif '7' <= s[i] <= '9':
                    # 17 18 19
                    dp[i] += dp[i-2] if i-2 >= 0 else 1
            elif s[i] == '*':
                if s[i-1] == '1':
                    dp[i] += dp[i-2] * 9 if i-2 >= 0 else 9
                elif s[i-1] == '2':
                    dp[i] += dp[i-2] * 6 if i-2 >= 0 else 6
            # 必须在最后面
            elif s[i-1] == '1' or s[i-1] == '2' and s[i] <= '6':
                # 前面有可组合的  # i=2时 只有自己
                dp[i] += dp[i-2] if i-2 >= 0 else 1
            dp[i] %= mod
        return dp[-1]